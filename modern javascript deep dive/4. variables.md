# 변수

데이터 : 애플리케에션에서 다루는 단위  
변수: 데이터를 관리하기 위한 핵심 개념

## 변수란

```javascript
10 + 20
```

자바스크립트 엔진은 위의 식을 평가(evaluate)하기 위해 기호(리터럴과 연산자)를 알고, 해석(파싱) 할 수 있어야 한다. 위의 연산을 수행하게 되면 `+` 연산자를 통해 좌 피연산자와 우 피연산자를 읽고 그 값을 더해야 한다. 이에 좌우 피연산자를 메모리 셀에 저장하고 더한 결과를 임의의 메모리 셀에 저장한다. 그러나 위의 평가식의 결과값은 읽히지 않았기 때문에 결과값 30을 사용하기 위해서는 저장된 메모리 셀에 직접 접근해야하는 방법밖에 없다. 그러나 자바스크립트는 개발자의 메모리의 직접 접근을 허용하지 않으므로, 변수를 통해 접근해야 한다. 따라서 변수의 정의는 다음과 같다.

변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름, 값의 위치를 가리키는 상징적인 이름

```javascript
//변수에 여러 개의 값을 저장하는 방법

//객체나 배열같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값으로 사용할 수 있다.
let user = { id: 1, name: 'lee' }
```

이 변수를 통해 위험하게 메모리를 직접 접근하지 않고도 안전하게 값을 저장하고 참조할 수 있다.

```javascript
let res = 10 + 20
```

위의 식은 평가되는 시점에서 메모리 상의 10과 20을 더한 결과인 30이 저장된 메모리 셀에 `res`라는 이름을 붙인다.

위의 식에서 `res`는 `변수 이름`이라 불리고, `30`은 `변수 값`이라 한다. 변수에 값을 저장하는 것을 `할당(assignment, 대입, 저장, 배정)` 이라 하고, 변수에 저장된 변수 값을 읽어오는 과정을 `참조`라 한다.

변수 이름은 사람을 위해 사람이 이해할 수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름이다. 사람이 이해할 수 있는 언어로 명명한 변수 이름을 통해 변수의 값을 명확히 알 수 있다. 좋은 이름의 변수는 가독성을 높이는 부수적인 효과도 있다.

## 식별자

변수 이름을 `식별자(identifier)`라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 의미한다. 앞에서 살펴본 `res`와 같은 식별자들은 메모리 주소를 저장하고 있다. 따라서 식별자는 메모리 주소에 붙인 이름이라 할 수 있다. 사실 `식별자`의 범주 안에는 변수 이름 뿐 아니라, 클래스, 함수 등의 이름들이 포함된다. 이러한 식별자들은 명명 규칙을 따라야 하며, 선언을 통해 자바스크립트 엔진에게 존재를 알린다.

## 변수 선언

변수 선언`variable declaration`은 변수를 생성하는 것을 의미한다. 세부적으로는 변수 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 한다.

변수를 사용하려면 반드시 선언이 되어야 한다. 변수를 선언하는 키워드로는 `var`, `let`, `const` 를 이용할 수 있다. ES6에서 `let`,`const`가 도입되기 전까지 자바스크립트에서는 `var`로만 변수를 선언할 수 있었다.

### var 키워드

```javascript
var score // 변수 선언
```

위의 코드는 자바스크립트 엔진에서 확보한 임의의 메모리 셀에 score라는 변수 이름을 등록한 것이다. 아직 해당 메모리 셀에 아무런 값도 할당되어있지 않으므로, 자바스크립트 엔진에서는 `undefined`라는 값을 암묵적으로 할당하여 배정한다. 이 `undefined`라는 값은 자바스크립트에서의 원시 타입의 값`primitive value` 이다.

```

자바스크립트 엔진은 변수 선언을 다음의 두 단계로 수행한다.

1. 선언 단계: 변수 이름을 통해서 자바스크립트 엔진에 이름을 알린다.
2. 할당 단계: 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 undefined를 할당해 초기화한다.
```

```text
변수 이름은 어디에 등록되는가?

변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행 컨텍스트는 자바스크립트 엔진이 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

변수 이름과 변수 값은 실행 컨텍스트 내에 key/value 형태인 객체로 등록되어 관리된다.
```

var 키워드를 통한 변수 선언은 선언 단계와 초기화 단계가 동시에 수행된다. `var score;`는 선언단계를 통해 변수 이름 score를 등록하고, 초기화 단계를 통해 score 변수에 암묵적으로 undefined 값이 할당된다.

초기화 단계를 거치지 않으면, 확보된 메모리에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 이런 값은 `쓰레기 값(garbage value)`이라 불린다. js에서는 초기화 단계를 암묵적으로 수행하기 때문에 이러한 쓰레기 값으로부터 안전하다.

변수를 비롯한 모든 식별자는 선언 후에 사용할 수 있다. 선언되지 않은 식별자를 접근하려고 하면 `ReferenceError`가 발생한다.

## 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score)

var score
```

위의 코드는 score가 선언되기 이전 시점에 score를 참조했으므로 ReferenceError가 발생할 것 같지만, 변수 선언을 평가하는 시점은 코드를 실행하는 runtime 이전에 수행되기 때문에 문제가 되지 않는다. 이러한 동작은 변수 선언 뿐 아니라 모든 식별자에 적용되며, 이러한 동작을 `호이스팅` 이라 한다.

### 그러나 let과 const는 호이스팅이 안되는 것처럼 보인다!

```javascript
console.log(score)
score = 80
let score
console.log(score)
```

위의 코드를 실행하면

```javascript
VM204:1 Uncaught ReferenceError: score is not defined
    at <anonymous>:1:13
```

라는 에러를 받을 수 있다. 이러한 이유는 모든 식별자는 호이스팅되나, `var`키워드만 `undefined`로 초기화되고, `let`과 `const` 식별자 키워드로 정의된 식별자들은 초기화되지 않기 때문이다. `let`과 `const` 는 자바스크립트 언어의 런타임 도중 `lexical binding` 이 평가되는 시점에서 초기화된다. 따라서 `let`과 `const` 는 값을 할당하기 전까지는 안에 참조된 값을 읽을 수 없다. 이러한 값을 읽을 수 없는 시간대를 `Temporal Dead Zone`이라 한다. 자바스크립트 런타임에서는 이 식별자가 선언된 라인에서 해당 식별자에 할당된 값을 찾을 수 없으면 undefined를 배정(`let`키워드의 경우)하거나, 에러를 반환할 것이다(`const`의 경우)

## 값의 할당

변수에 값을 할당하는 연산자는 `=` 이다. 할당 연산자는 rValue를 lValue에 할당한다.

```javascript
var score
score = 80

var score2 = 80
//이와 같이 한 줄로 줄일 수도 있다.
```

위의 `호이스팅` 개념을 떠올려, 변수의 선언 시점과 할당이 이루어지는 시점이 다름을 유의하라.

```javascript
console.log(score) //undefined
var score = 80
console.log(score) //80
```

```javascript
console.log(score) //undefined
score = 80
var score
console.log(score) //80
```

위의 예제는 score 변수 선언이 런타임 이전에 평가되고, defined 값이 배정되어 첫 console.log 에서는 undefined가, 두 번째 줄에서 score가 가리키는 메모리 주소에 80이 배정되고, 세 번째 줄은 런타임에서 아무런 동작도 하지 않으며, 마지막 줄에서는 80 이 출력된다.

## 값의 재할당

값의 재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 할당하는 것이다. `var`키워드로 선언된 변수는 재할당할 수 있다. 재할당을 수행할 수 없는 값은 `변수`가 아니라 `상수`라 한다.

```text
const 키워드

ES6에서 도입된 const 키워드를 사용하여 선언한 변수는 재할당이 금지된다. 그러나 반드시 상수만을 위해 사용되지는 않는다.
```

```javascript
var score = 80
score = 90
```

위의 코드는 다음과 같은 절차로 수행된다.
--런타임 이전

1. score가 실행 컨텍스트에 저장되고, 메모리가 할당된다.
2. score가 할당된 메모리 셀에 undefined의 값이 배정된다.
   --런타임
3. 첫 번째 줄의 식이 평가되며, `=` 연산자를 평가하면서 80이 임의의 메모리에 할당되고, score 키워드에는 80이 할당된 메모리의 값을 저장한다.
4. 두 번째 줄의 식이 평가되며, `=` 연산자를 평가하면서 90이 임의의 메모리에 할당되고, score 키워드에는 90이 할당된 메모리의 값을 저장한다.

따라서 최종 실행된 이후에는 `undefined` 와 `80`은 어떤 변수도 값으로 가지고 있지 않는다. 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다. 그러나 명시적으로 가비지 콜렉터를 호출할 수 없으며, 언제 메모리에서 해제될지는 알 수 없다.

### 가비지 콜렉터

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 의미한다. 자바스크립트는 managed language 이므로 가비지 콜렉터를 통해 메모리 누수를 방지한다.

#### 가비지 콜렉터의 동작 방식

1. reference counting

특정 값이 참조된 시점에서 개수를 증가시키며, 참조되지 않는 시점에서 메모리를 해제하는 방식이다.

```javascript
var x = {
  a: {
    b: 2
  }
}
/*
a'    -> 0x000 = | {b:2}  |
x     -> 0x001 = | {a:a'} |
*/

// 2개의 오브젝트가 생성되었다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조된다.
// 나머지 하나는 'x' 변수에 할당되었다.
// 명백하게 가비지 콜렉션 수행될 메모리는 하나도 없다.

var y = x // 'y' 변수는 위의 오브젝트를 참조하는 두 번째 변수이다.
/*
a'    -> 0x000 = | {b:2}  |
y,x   -> 0x001 = | {a:a'} |
*/

x = 1 // 이제 'y' 변수가 위의 오브젝트를 참조하는 유일한 변수가 되었다.
/*
a'    -> 0x000 = | {b:2}  |
y     -> 0x001 = | {a:a'} |
x     -> 0x002 = | 1      |
*/

var z = y.a // 위의 오브젝트의 'a' 속성을 참조했다.
/*
z,a'  -> 0x000 = | {b:2}  |
y     -> 0x001 = | {a:a'} |
x     -> 0x002 = | 1      |
*/

// 이제 'y.a'는 두 개의 참조를 가진다.
// 'y'가 속성으로 참조하고 'z'라는 변수가 참조한다.

y = 'yo' // 이제 맨 처음 'y' 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없다.
/*
z,a'  -> 0x000 = | {b:2}  |
b'    -> 0x001 = | {a:a'} |
x     -> 0x002 = | 1      |
y     -> 0x003 = | 'yo'   |
*/

// (역자: 참조하는 유일한 변수였던 y에 다른 값을 대입했다)
// 이제 오브젝트에 가비지 콜렉션이 수행될 수 있을까?
// 아니다. 오브젝트의 'a' 속성이 여전히 'z' 변수에 의해 참조되므로
// 메모리를 해제할 수 없다.

z = null // 'z' 변수에 다른 값을 할당했다.
/*
~~a'~~-> 0x000 = | {b:2}  |
~~b'~~-> 0x001 = | {a:a'} |
x     -> 0x002 = | 1      |
y     -> 0x003 = | 'yo'   |
z     -> 0x004 = | null   | 
*/

// 이제 맨 처음 'x' 변수가 참조했던 오브젝트를 참조하는
// 다른 변수는 없으므로 가비지 콜렉션이 수행된다.
```

Reference Counting은 IE 6,7 에서 사용되었으나, 다음과 같은 `순환 참조` 문제를 해결하지 못한다. 실제로 해당 브라우저에서는 다음과 같은 상황에 메모리 누수가 발생했다.

```javascript
function f() {
  var x = {}
  /*
  x            -> 0x000 = | {} |
  */
  var y = {}
  /*
  x,y          -> 0x000 = | {} |
  */
  x.a = y // x는 y를 참조한다.
  /*
  x,y,x.a      -> 0x000 = | {} |
  */
  o2.a = o // y는 a를 참조한다.
  /*
  x,y,x.a,y.a  -> 0x000 = | {} |
  */
  return 'azerty'
}
/*
원래는 이 렉시컬 스코프가 끝나는 시점에서 x와 y는 더 이상 참조되지 않으므로 메모리가 해제되어야 하지만, 0x000는 서로의 필드가 상호 참조하고 있기 때문에 해제할 수 없다.
*/
f()

var div
window.onload = function () {
  div = document.getElementById('myDivElement')
  div.circularReference = div
  div.lotsOfData = new Array(10000).join('*')
}

/*
myDivElement는 자기 자신의 div.circularReference와 순환 참조를 이루고 있다.
만약 해당 DOM 엘리멘트가 lotsOfData 속성과 같이 많은 데이터를 들고 있다면, 이 메모리는 영원히 해제되지 않을 것이고, 브라우저를 느려지게 만들 것이다.
*/
```

2. mark and sweep

이 알고리즘은 `닿을 수 있는 객체`와 `닿을 수 없는 객체`로 객체를 구분한다. 이 알고리즘은 `roots`라는 전역 오브젝트의 집합을 가지며, 가비지 콜렉터는 roots가 참조하는 오브젝트들로부터 재귀적으로 참조하는 자식 객체들을 `닿을 수 있는 객체`로 정의한다. 그리고 닿을 수 없는 객체에 대해서는 가비지 콜렉션을 수행한다. 참조되지 않는 객체는 모두 닿을 수 없는 객체이고, 역은 성립하지 않기 때문에 효율적이다. 2012년 이후의 현대 브라우저들은 모두 이 방식을 이용하여 가지비 콜렉션을 수행한다.

## 식별자 명명규칙

식별자의 이름은 다음의 규칙을 만족해야 한다.

- 특수문자를 제외한 문자,숫자,\_,$ 를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, \_, $ 로 시작해야 한다. 숫자로 시작하는 것은 허용되지 않는다.
- 예약어는 식별자로 사용할 수 없다.

javascript의 예약어 목록 \*가 붙은 키워드는 strict mode에서는 사용 불가

- await
- break
- case
- catch
- class
- const
- continue
- debugger
- default
- delete
- do
- else
- enum
- export
- extends
- false
- finally
- for
- function
- if
- implements\*
- import
- in
- instanceof
- interface\*
- let\*
- new
- null
- package\*
- private\*
- protected\*
- public\*
- return
- super
- static\*
- switch
- this
- throw
- true
- try
- typeof
- var
- void
- while
- with
- yield\*

ES5 부터 유니코드 문자도 변수명으로 사용할 수 있게 되었다. 이는 이모지, CJK 등의 문자도 사용할 수 있다는 것이다.

자바스크립트의 식별자는 대소문자를 구별한다.
